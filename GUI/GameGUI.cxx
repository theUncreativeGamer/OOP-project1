// generated by Fast Light User Interface Designer (fluid) version 1.0308

#include "GameGUI.h"

#include <FL/Fl_PNG_Image.H>
namespace gui
{


    // Static Fl_Image s
    static Fl_PNG_Image image_empty("Images/empty.png");
    static Fl_PNG_Image image_1("Images/1.png");
    static Fl_PNG_Image image_2("Images/2.png");
    static Fl_PNG_Image image_3("Images/3.png");
    static Fl_PNG_Image image_4("Images/4.png");
    static Fl_PNG_Image image_5("Images/5.png");
    static Fl_PNG_Image image_6("Images/6.png");
    static Fl_PNG_Image image_7("Images/7.png");
    static Fl_PNG_Image image_8("Images/8.png");
    static Fl_PNG_Image* image_number[] =
    {
        &image_empty,
        &image_1,
        &image_2,
        &image_3,
        &image_4,
        &image_5,
        &image_6,
        &image_7,
        &image_8,
    };
    static Fl_PNG_Image image_flag("Images/flag.png");
    static Fl_PNG_Image image_failFlag("Images/useless-flag.png");
    static Fl_PNG_Image image_mine("Images/mine.png");
    static Fl_PNG_Image image_succMine("Images/yes-mine.png");
    static Fl_PNG_Image image_questionMark("Images/wat.png");
    //////////////////////

    size_t Updateable::nextObjectID = 0;
    std::vector<Updateable*> Updateable::stuffsToUpdate;

    /**
     Every inherited class should call this base constructor so that it can be called by the UpdateAll function.
    */
    Updateable::Updateable() {
        stuffsToUpdate.push_back(this);
        id = nextObjectID;
        nextObjectID++;
    }

    Updateable::~Updateable() {
        std::vector<Updateable*>::iterator it = std::find(stuffsToUpdate.begin(), stuffsToUpdate.end(), this);
        if (it != stuffsToUpdate.end())
            stuffsToUpdate.erase(it);
    }

    bool Updateable::operator==(const Updateable& another)
    {
        if (id == another.id) return true;
        return false;
    }

    void Updateable::Update()
    {
    }

    void Updateable::UpdateAll() {
        for (Updateable* u : stuffsToUpdate) {
            u->Update();
        }
        //Fl::flush();
    }
    void TileButton::Update()
    {
        //std::cout << "lmao\n";
        if (board->GetGameState() == GameBoardState::Playing)
        {
            if (tile->IsMasking())
            {
                switch (tile->GetState())
                {
                case TileState::Clean:
                    image(image_empty);
                    break;
                case TileState::Flagged:
                    image(image_flag);
                    break;
                case TileState::QuestionMark:
                default:
                    image(image_questionMark);
                    break;
                }
            }
            else
            {
                deactivate();
                if (tile->IsMine())
                {
                    image(image_mine);
                }
                else
                {
                    image(image_number[tile->GetMineCount()]);
                }
            }
        }
        else
        {

            if (tile->IsMine())
            {
                deactivate();
                if (tile->IsFlagged())
                {
                    image(image_succMine);
                }
                else
                {
                    image(image_mine);
                }
            }
            else
            {
                if (tile->IsFlagged())
                {
                    deactivate();
                    image(image_failFlag);
                }
                else
                {
                    if (!tile->IsMasking())
                    {
                        deactivate();
                        image(image_number[tile->GetMineCount()]);
                    }
                    else
                    {
                        image(image_empty);
                    }
                }
            }
        }
        redraw_label();
    }
    TileButton::TileButton(const GameBoard& boardReference, int gridY, int gridX)
        : Fl_Button(tile00PositionX + width * gridX, tile00PositionY + height * gridY, width, height),
        Updateable()
    {
        std::cout << "New button would be added at X: " << tile00PositionX + width * gridX << " and Y: " << tile00PositionY + height * gridY << std::endl;
        board = &boardReference;
        tile = &boardReference.GetTile(gridY, gridX);
        this->column = gridX;
        this->row = gridY;
        this->box(FL_GTK_UP_BOX);
        this->down_box(FL_GTK_DOWN_BOX);
        this->color((Fl_Color)37);
        this->selection_color((Fl_Color)33);
        this->labeltype(FL_NORMAL_LABEL);
        this->labelfont(0);
        this->labelsize(26);
        this->labelcolor(FL_FOREGROUND_COLOR);
        this->align(Fl_Align(FL_ALIGN_CENTER));
        this->when(FL_WHEN_RELEASE);
        this->activate();
        this->set_visible();
        this->callback((Fl_Callback*)TileButton::ButtonCallback, this);
        gameArea->add(this);
    }

    void TileButton::ButtonCallback(Fl_Widget* widget, void* data)
    {
        TileButton* theButton = static_cast<TileButton*>(data);
        if (Fl::event_button() == FL_LEFT_MOUSE)
        {
            bool endGame = gameController.LeftClick(theButton->row, theButton->column);
            Updateable::UpdateAll();
            if (endGame)
            {
                std::cout << "Game has ended\n";
                MakeResultWindow();
            }
        }
        else if (Fl::event_button() == FL_RIGHT_MOUSE)
        {
            gameController.RightClick(theButton->row, theButton->column);
            Updateable::UpdateAll();
        }
    }

    void GenerateNewBoardWithFixedAmount(const int& height, const int& width, const int& mineCount) {
        std::cout << "Generating new board with Height: " << height << " Width: " << width << " Mine count: " << mineCount << std::endl;
        if (gameController.LoadCount(height, width, mineCount))
            GenerateButtonsForTheNewBoard();
    }

    void GenerateNewBoardWithRandomChance(const int& height, const int& width, const float& mineRate) {
        std::cout << "Generating new board with Height: " << height << " Width: " << width << " Mine rate: " << mineRate << std::endl;
        if (gameController.LoadRate(height, width, mineRate))
            GenerateButtonsForTheNewBoard();
    }

    void DeleteAllMineButtons()
    {
        for (auto p : gameBoardUIButtons)
        {
            gameArea->remove(p);
            delete p;
        }

        gameBoardUIButtons.clear();
    }

    void GenerateButtonsForTheNewBoard()
    {
        int boardHeight = gameController.GetBoard().GetHeight();
        int boardWidth = gameController.GetBoard().GetWidth();
        const GameBoard& boardRef = gameController.GetBoard();

        mainWindow->resize(mainWindow->x(), mainWindow->y(), 30 * boardWidth + 50, 30 * boardHeight + 125);

        std::cout << "Generating buttons for a board with height: " << boardHeight << " and width: " << boardWidth << std::endl;

        DeleteAllMineButtons();

        gameBoardUIButtons.resize(boardHeight * boardWidth);
        for (int y = 0; y < boardHeight; y++)
        {
            for (int x = 0; x < boardWidth; x++)
            {
                gameBoardUIButtons[boardWidth * y + x] = new TileButton(boardRef, y, x);
            }
        }

        Updateable::UpdateAll();
    }

    Fl_Double_Window* customGameWindow = (Fl_Double_Window*)0;

    Fl_Value_Input* heightInputBox = (Fl_Value_Input*)0;

    Fl_Value_Input* widthInputBox = (Fl_Value_Input*)0;

    Fl_Round_Button* fixedAmountOption = (Fl_Round_Button*)0;

    static void cb_fixedAmountOption(Fl_Round_Button*, void*) {
        mineChanceBox->hide();
        mineAmountBox->show();
        okButtonFixedAmount->show();
        okButtonFixedAmount->activate();
        okButtonRandomChance->hide();
        okButtonRandomChance->deactivate();
    }

    Fl_Round_Button* randomChanceOption = (Fl_Round_Button*)0;

    static void cb_randomChanceOption(Fl_Round_Button*, void*) {
        mineAmountBox->hide();
        mineChanceBox->show();
        okButtonFixedAmount->hide();
        okButtonFixedAmount->deactivate();
        okButtonRandomChance->show();
        okButtonRandomChance->activate();
    }

    Fl_Value_Input* mineAmountBox = (Fl_Value_Input*)0;

    Fl_Value_Input* mineChanceBox = (Fl_Value_Input*)0;

    Fl_Button* okButtonFixedAmount = (Fl_Button*)0;

    static void cb_okButtonFixedAmount(Fl_Button*, void*) {
        GenerateNewBoardWithFixedAmount(heightInputBox->value(), widthInputBox->value(), mineAmountBox->value());
        customGameWindow->hide();
    }

    Fl_Button* okButtonRandomChance = (Fl_Button*)0;

    static void cb_okButtonRandomChance(Fl_Button*, void*) {
        GenerateNewBoardWithRandomChance(heightInputBox->value(), widthInputBox->value(), mineChanceBox->value());
        customGameWindow->hide();
    }

    Fl_Button* cancelButton = (Fl_Button*)0;

    static void cb_cancelButton(Fl_Button*, void*) {
        customGameWindow->hide();
    }

    Fl_Double_Window* MakeCustomBoardWindow() {
        { customGameWindow = new Fl_Double_Window(376, 204, "New Game Setup");
        { heightInputBox = new Fl_Value_Input(115, 15, 80, 30, "Height");
        heightInputBox->minimum(1);
        heightInputBox->maximum(99);
        heightInputBox->step(1);
        heightInputBox->value(10);
        } // Fl_Value_Input* heightInputBox
        { widthInputBox = new Fl_Value_Input(115, 50, 80, 30, "Width");
        widthInputBox->minimum(1);
        widthInputBox->maximum(99);
        widthInputBox->step(1);
        widthInputBox->value(10);
        } // Fl_Value_Input* widthInputBox
        { Fl_Group* o = new Fl_Group(115, 85, 235, 30, "Mode");
        o->align(Fl_Align(292));
        { fixedAmountOption = new Fl_Round_Button(115, 85, 15, 30, "Fixed Amount");
        fixedAmountOption->type(102);
        fixedAmountOption->down_box(FL_ROUND_DOWN_BOX);
        fixedAmountOption->callback((Fl_Callback*)cb_fixedAmountOption);
        fixedAmountOption->align(Fl_Align(296));
        } // Fl_Round_Button* fixedAmountOption
        { randomChanceOption = new Fl_Round_Button(224, 85, 15, 30, "Random Chance");
        randomChanceOption->type(102);
        randomChanceOption->down_box(FL_ROUND_DOWN_BOX);
        randomChanceOption->callback((Fl_Callback*)cb_randomChanceOption);
        randomChanceOption->align(Fl_Align(FL_ALIGN_RIGHT));
        } // Fl_Round_Button* randomChanceOption
        o->end();
        } // Fl_Group* o
        { mineAmountBox = new Fl_Value_Input(115, 120, 80, 30, "Mine Amount");
        mineAmountBox->minimum(1);
        mineAmountBox->maximum(999);
        mineAmountBox->step(1);
        mineAmountBox->value(10);
        } // Fl_Value_Input* mineAmountBox
        { mineChanceBox = new Fl_Value_Input(115, 120, 80, 30, "Mine Chance");
        mineChanceBox->minimum(0.01);
        mineChanceBox->hide();
        } // Fl_Value_Input* mineChanceBox
        { okButtonFixedAmount = new Fl_Button(165, 160, 90, 30, "OK");
        okButtonFixedAmount->callback((Fl_Callback*)cb_okButtonFixedAmount);
        } // Fl_Button* okButtonFixedAmount
        { okButtonRandomChance = new Fl_Button(165, 160, 90, 30, "OK");
        okButtonRandomChance->callback((Fl_Callback*)cb_okButtonRandomChance);
        okButtonRandomChance->hide();
        okButtonRandomChance->deactivate();
        } // Fl_Button* okButtonRandomChance
        { cancelButton = new Fl_Button(270, 160, 90, 30, "Cancel");
        cancelButton->callback((Fl_Callback*)cb_cancelButton);
        } // Fl_Button* cancelButton
        customGameWindow->end();
        } // Fl_Double_Window* customGameWindow
        return customGameWindow;
    }

    double SyncFunction_remainingFlagCountDisplay()
    {
        int mineCount = gameController.GetBoard().getMineCount();
        int flagCount = gameController.GetBoard().getFlagCount();
        std::cout << mineCount << ", " << flagCount << std::endl;
        return (double)gameController.GetBoard().getMineCount() - gameController.GetBoard().getFlagCount();
    }

    Fl_Double_Window* mainWindow = (Fl_Double_Window*)0;

    static void cb_mainWindow(Fl_Double_Window*, void*) {
        std::cout << "Closing main window!!!" << std::endl;
        if (resultWindow != NULL)resultWindow->hide();
        if (customGameWindow != NULL)customGameWindow->hide();
        mainWindow->hide();
    }

    Fl_Menu_Bar* menuBar = (Fl_Menu_Bar*)0;

    static void cb_customGameOption(Fl_Menu_*, void*) {
        if (customGameWindow == NULL)customGameWindow = MakeCustomBoardWindow();
        customGameWindow->show();
        //std::cout<<"Make a new windoe!"<<std::endl;
    }

    static void cb_uselessTestButton(Fl_Menu_*, void*) {
        std::cout << "I am useless :)\n";
    }

    Fl_Menu_Item menu_menuBar[] = {
     {"New Game", 0,  0, 0, 64, (uchar)FL_SHADOW_LABEL, 13, 18, 0},
     {"Custom", 0,  (Fl_Callback*)cb_customGameOption, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
     {0,0,0,0,0,0,0,0,0},
     {"Test", 0,  (Fl_Callback*)cb_uselessTestButton, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
     {0,0,0,0,0,0,0,0,0}
    };

    Fl_Group* statBar = (Fl_Group*)0;

    SyncedValueOutput* remainingFlagCountDisplay = (SyncedValueOutput*)0;

#include <FL/Fl_Image.H>

    Fl_Group* gameArea = (Fl_Group*)0;

    Fl_Button* uiTestButton = (Fl_Button*)0;



    int MakeMainWindow(int argc, char** argv) {
        { mainWindow = new Fl_Double_Window(350, 425, "Minesweeper");
        mainWindow->callback((Fl_Callback*)cb_mainWindow);
        mainWindow->default_icon(&image_mine);
        { menuBar = new Fl_Menu_Bar(0, 0, 350, 30, "Tool Bar");
        menuBar->menu(menu_menuBar);
        } // Fl_Menu_Bar* menuBar
        { statBar = new Fl_Group(0, 30, 350, 45);
        statBar->box(FL_ENGRAVED_BOX);
        statBar->color((Fl_Color)38);
        statBar->selection_color((Fl_Color)81);
        { remainingFlagCountDisplay = new SyncedValueOutput(40, 35, 75, 35);
        remainingFlagCountDisplay->box(FL_EMBOSSED_BOX);
        remainingFlagCountDisplay->color(FL_FOREGROUND_COLOR);
        remainingFlagCountDisplay->image(image_flag);
        remainingFlagCountDisplay->labelsize(26);
        remainingFlagCountDisplay->minimum(-999);
        remainingFlagCountDisplay->maximum(999);
        remainingFlagCountDisplay->value(000);
        remainingFlagCountDisplay->textfont(14);
        remainingFlagCountDisplay->textsize(28);
        remainingFlagCountDisplay->textcolor(FL_BACKGROUND2_COLOR);
        remainingFlagCountDisplay->SetSyncFunction(SyncFunction_remainingFlagCountDisplay);
        } // Fl_Value_Output* remainingFlagCountDisplay
        statBar->end();
        } // Fl_Group* statBar
        { gameArea = new Fl_Group(0, 75, 350, 350);
        gameArea->box(FL_BORDER_BOX);
        gameArea->end();
        Fl_Group::current()->resizable(gameArea);
        } // Fl_Group* gameArea

        mainWindow->end();
        } // Fl_Double_Window* mainWindow
        mainWindow->show(argc, argv);
        return Fl::run();
    }

    SyncedValueOutput::SyncedValueOutput(int X, int Y, int W, int H, char* L)
        : Fl_Value_Output(X, Y, W, H, L),
        Updateable()
    {
        syncFunction = NULL;
    }

    void SyncedValueOutput::SetSyncFunction(double (*function)(void))
    {
        syncFunction = function;
    }

    void SyncedValueOutput::Update()
    {
        if (syncFunction != NULL)
        {
            std::cout << "Setting value to " << (*syncFunction)() << std::endl;
            value((*syncFunction)());
        }
    }

    Fl_Double_Window* resultWindow = (Fl_Double_Window*)0;

    Fl_Output* resultText = (Fl_Output*)0;

    static Fl_Button* yesButton = (Fl_Button*)0;
    static void cb_yesButton(Fl_Menu_*, void*)
    {
        gameController.Replay();
        DeleteAllMineButtons();
        resultWindow->hide();
        customGameWindow->show();
    }

    static Fl_Button* noButton = (Fl_Button*)0;
    static void cb_noButton(Fl_Menu_*, void*)
    {
        if (resultWindow != NULL)resultWindow->hide();
        if (customGameWindow != NULL)customGameWindow->hide();
        mainWindow->hide();
    }

    void MakeResultWindow() {
        { resultWindow = new Fl_Double_Window(360, 200, "Game Result");
        { resultText = new Fl_Output(70, 30, 200, 65, "You ");
        resultText->box(FL_NO_BOX);
        resultText->labelfont(13);
        resultText->labelsize(25);
        resultText->textfont(14);
        resultText->textsize(40);
        resultText->align(Fl_Align(FL_ALIGN_LEFT_TOP));
        // set this text to win or lose
        switch (gameController.GetBoard().GetResult())
        {
        case GameBoardResult::Lose:
            resultText->value("Lose!");
            break;
        case GameBoardResult::Win:
            resultText->value("Win!");
            break;
        default:
            resultText->value("WHAT?");
            break;
        }
        } // Fl_Output* resultText
        { Fl_Group* o = new Fl_Group(20, 140, 325, 55, "Start a new game?");
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        { yesButton = new Fl_Button(45, 140, 180, 50, "YES");
        yesButton->color((Fl_Color)225);
        yesButton->selection_color(FL_BLUE);
        yesButton->labelfont(7);
        yesButton->labelsize(48);
        yesButton->labelcolor((Fl_Color)79);
        yesButton->callback((Fl_Callback*)cb_yesButton);
        } // Fl_Button* yesButton
        { noButton = new Fl_Button(265, 155, 80, 35, "nah");
        noButton->color((Fl_Color)34);
        noButton->selection_color((Fl_Color)33);
        noButton->labelfont(8);
        noButton->labelsize(15);
        noButton->labelcolor((Fl_Color)55);
        noButton->callback((Fl_Callback*)cb_noButton);
        } // Fl_Button* yesButton
        o->end();
        } // Fl_Group* o
        resultWindow->end();
        } // Fl_Double_Window* resultWindow
        resultWindow->show();
    }
}
